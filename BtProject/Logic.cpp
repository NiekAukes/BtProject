#include "Logic.h"

//bool BiValue::Value()
//{
//	bool v;
//	switch (type)
//	{
//	case And:
//		v = (val1->Value() && val2->Value());
//		return v;
//		break;
//	case Or:
//		return (val1->Value() || val2->Value());
//		break;
//	case Nand:
//		return !(val1->Value() && val2->Value());
//		break;
//	case Nor:
//		return !(val1->Value() || val2->Value());
//		break;
//	case Xor:
//		return (!(val1->Value() && val2->Value()) && (val1->Value() || val2->Value()));
//		break;
//	case Xnor:
//		return !(!(val1->Value() && val2->Value()) && (val1->Value() || val2->Value()));
//		break;
//	default:
//		return false;
//		break;
//	}
//	return false;
//
//}

Logic* Logic::strToLogic(std::string strin)
{

	//size_t found = strin.find(str1);
	//if (found != string::npos)
	//	cout << "First occurrence is " << found << endl;

	//// Find next occurrence of "geeks". Note here we pass 
	//// "geeks" as C style string. 
	//char arr[] = "geeks";
	//found = str.find(arr, found + 1);
	//if (found != string::npos)
	//	cout << "Next occurrence is " << found << endl;
	return nullptr;
}
